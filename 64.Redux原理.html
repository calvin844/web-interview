<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>64.Redux原理</title>
</head>

<body>
    <script>
        /*
            Redux是一个负责管理JavaScript数据的状态容器工具
            它是一个独立的库，与React并没有直接关系，是React-Redux将它们联系起来的
            Redux主要解决了复杂应用的状态管理问题，可以跨层级任意传递数据
            
            答题：
            Redux就是一个经典的发布订阅器
        */


        // 手写Redux的createStore方法
        /*
            @param {Function} reducer   => reducer
            @param {ang} preloadedState => 初始化的state,用的相对较少，一般在服务器渲染的时候使用
            @param {Function} enhancer  => 中间件
        */
        export default function createStore(reducer, preloadedState, enhance) {
            // 实现第二个形参选填
            // 只有当第二参数传入的是中间件才会执行下面的代码
            if (typeof preloadedState === 'function' && typeof enhance === "undefined") {
                enhance = preloadedState;
                preloadedState = undefined;
            }
            let currentReducer = reducer;
            let currentState = preloadedState; // 整个应用所有的State都存在这个变量里
            let currentListeners = [] //订阅传进来的回调函数 

            // 这是一个很重要的设计
            let nextListeners = currentListeners;
            function getState() {
                return currentState
            }

            function subscribe(listener) {
                if (nextListeners === currentListeners) {
                    // 浅复制
                    // 实际上 nextListeners 就是 currentListeners，避免直接操作currentListeners
                    // 因为其他地方会用到 currentListeners，从而造成数据不一致
                    nextListeners = [...currentListeners]
                }
                nextListeners.push(listener);
                return function unsubscribe() {
                    if (nextListeners === currentListeners) {
                        // 浅复制
                        nextListeners = [...currentListeners];
                    }
                    const index = nextListeners.indexOf(listener);
                    nextListeners.splice(index, 1)
                }
            }

            function dispatch(action) {
                currentState = currentReducer(currentState, action);//调用 action 来更新数据
                const listeners = (currentListeners = nextListeners);//保证当前的 listeners 是最新的
                for (let i = 0; i < listeners.length; i++) {
                    listeners[i]();// 依次执行回调函数
                }
                return action
            }

            // 手动触发一次 dispatch，初始化
            dispatch({ type: 'INIT' });

            return {
                getState,
                dispatch,
                subscribe
            }
        }

        /*
            总结：
            Redux就是帮我们用一个变量存储所有的State，并且提供了发布功能来修改数据，以及订阅功能来触发回调
            但是Redux不进行添加订阅，这就需要通过react-redux来处理了
        */

        // 手写react-redux中的Provider
        import React from 'react'
        import PropTypes from 'prop-types'
        export default class Provider extends React.Component {
            // content 往所有子孙组件传递数据
            // props   父组件往子组件传递数据
            // state   组件自身的数据

            // 声明一个 context 数据
            getChildContext() {
                return { store: this.store }
            }

            constructor(props, context) {
                super(props, context)
                this.store = props.store
            }
            render() {
                return React.Children.only(this.props.children)
            }
        }
        Provider.childrenContextTypes = {
            store: PropTypes.object
        }

        /*
            总结：
            Provider就是通过React的Context API把数据往下传
        */


        // 手写react-redux中的connect
        import React from 'react'
        import PropTypes from 'prop-types'

        // ()=>()=>{}  函数的柯里化
        // const sum = (a)=>{return (b) => a + b}
        // sum(1)(2) -> connect(mapStateToProps,mapDispatchToProps)(Comp)

        // HOC
        const connect = (mapStateToProps = state => state, mapDispatchToProps = {}) =>
            (WrapComponent) => {
                return class ConnectComponent extends React.Component {
                    static contextTypes = {
                        store: PropTypes.object
                    }

                    constructor(props, context) {
                        super(props, context)
                        this.state = {
                            props: {}// 声明了一个叫做 props 的 state
                        }
                    }

                    componentDidMount() {
                        const { store } = this.context //从Context 中拿到 store 对象
                    }
                }
            }
    </script>

</body>

</html>