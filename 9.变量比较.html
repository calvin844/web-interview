<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>9.变量比较</title>
</head>

<body>
	<script type="text/javascript">

			// ==时会默认转换类型再比较，===时是直接值比较
			// 1. 对象==字符串：把对象toString转为字符串
			// 2. null==undefined：相等的，但是和其他值比较都不相等
			// 3. NaN==NaN：不相等，NaN和谁都不相等，包括它自己
			// 4. 其他的都是转为数字："1" == true "1"转为数字1，true转为数字1，因此它们相等
			// 5. 同类型的比较为直接值比较

			// a为什么值的时候，下面代码成立
			// 第一种：a和数字比较时会调用toString方法，我们自定义toString方法，由于3次相等，所以toString就会调用3次，让它每次调用都输出不同的值
			// 延伸：valueOf也行，比较时先调用valueOf获取值，然后在调用toString，因此，我们重写valueOf(){return ++this.i}，也是可以的
			// var a = {
			// 	i: 0
			// 	toString() {
			// 		return ++this.i
			// 	}
			// }

			// 第二种：通过数据劫持实现，Object.defineProperty(需要监听的对象，监听的属性，设置get和set方法)
			// var i = 0 //不能使用a，因为每次get return ++a时又会重新触发get，导致死循环
			// Object.defineProperty(window, 'a', {
			// 	get() {
			// 		return ++i
			// 	}
			// })

			// 第三种：数组比较时也是先调用toString，我们把toString方法改为shift，每次把数组第一个元素返回并删除
			// var a = [1,2,3]
			// a.toString = a.shift;
			// if (a == 1 && a == 2 & a == 3) {
			// 	console.log('条件成立')
			// }
	</script>
</body>

</html>